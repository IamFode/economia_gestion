sswg[6] <- kmeans(k_data,6)$tot.withinss
sswg[7] <- kmeans(k_data,7)$tot.withinss
n <- length(life.expectancy)
for (K in 1:6){
H[K] <- (n-K-1)*(sswg[K]-sswg[K+1])/sswg[K+1]
}
H
plot(1:7,sswg[1:7])
km3 <- kmeans(k_data,3)
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
km3 <- kmeans(k_data,5)
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
as.character(country)[km3$cluster==4]
as.character(country)[km3$cluster==5]
plot(1:7,sswg[1:7])
km3 <- kmeans(k_data,3)
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
# install.packages("maps")
library(maps)
map(regions=c("Spain","Portugal","Morocco","Algeria","France","Canary Islands"),xlim=c(-20,5),ylim=c(27,44))
points(longitude,latitude,cex=0.25,pch=1)
text(longitude,latitude+0.20,city,cex=0.25)
# K-means clustering with K=2
map(regions=c("Spain","Portugal","Morocco","Algeria","France","Canary Islands"),xlim=c(-20,5),ylim=c(27,44))
points(longitude[km2$cluster==1],latitude[km2$cluster==1],cex=0.25,pch=1,col="red")
points(longitude[km2$cluster==2],latitude[km2$cluster==2],cex=0.25,pch=1,col="blue")
text(longitude[km2$cluster==1],latitude[km2$cluster==1]+0.20,city[km2$cluster==1],cex=0.25,col="red")
text(longitude[km2$cluster==2],latitude[km2$cluster==2]+0.20,city[km2$cluster==2],cex=0.25,col="blue")
# K-means clustering with K=3
map(regions=c("Spain","Portugal","Morocco","Algeria","France","Canary Islands"),xlim=c(-20,5),ylim=c(27,44))
points(longitude[km3$cluster==1],latitude[km3$cluster==1],cex=0.25,pch=1,col="red")
points(longitude[km3$cluster==2],latitude[km3$cluster==2],cex=0.25,pch=1,col="blue")
points(longitude[km3$cluster==3],latitude[km3$cluster==3],cex=0.25,pch=1,col="green")
text(longitude[km3$cluster==1],latitude[km3$cluster==1]+0.20,city[km3$cluster==1],cex=0.25,col="red")
text(longitude[km3$cluster==2],latitude[km3$cluster==2]+0.20,city[km3$cluster==2],cex=0.25,col="blue")
map(regions=c("Spain","Portugal","Morocco","Algeria","France","Canary Islands"),xlim=c(-20,5),ylim=c(27,44))
points(longitude,latitude,cex=0.25,pch=1)
text(longitude,latitude+0.20,city,cex=0.25)
map(regions=c("Australia","Austria","Belgium")
xlim=c(-20,5),ylim=c(27,44))
map(regions=c("Australia","Austria","Belgium"),
xlim=c(-20,5),ylim=c(27,44))
map(regions=c("Spain","Portugal","Morocco","Algeria","France","Canary Islands"),
xlim=c(-20,5),ylim=c(27,44))
points(longitude[km3$cluster==1],latitude[km3$cluster==1],cex=0.25,
pch=1,col="red")
points(longitude[km3$cluster==2],latitude[km3$cluster==2],cex=0.25,
pch=1,col="blue")
points(longitude[km3$cluster==3],latitude[km3$cluster==3],cex=0.25,
pch=1,col="green")
text(longitude[km3$cluster==1],latitude[km3$cluster==1]+0.20,
country[km3$cluster==1],cex=0.25,col="red")
text(longitude[km3$cluster==2],latitude[km3$cluster==2]+0.20,
country[km3$cluster==2],cex=0.25,col="blue")
text(longitude[km3$cluster==3],latitude[km3$cluster==3]+0.20,country[km3$cluster==3],cex=0.25,col="green")
km3 <- kmeans(k_data,3)
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
map(regions=c("Spain","Portugal","Morocco","Algeria","France","Canary Islands"),
xlim=c(-20,5),ylim=c(27,44))
points(longitude[km3$cluster==1],latitude[km3$cluster==1],cex=0.25,
pch=1,col="red")
points(longitude[km3$cluster==2],latitude[km3$cluster==2],cex=0.25,
pch=1,col="blue")
points(longitude[km3$cluster==3],latitude[km3$cluster==3],cex=0.25,
pch=1,col="green")
text(longitude[km3$cluster==1],latitude[km3$cluster==1]+0.20,
country[km3$cluster==1],cex=0.25,col="red")
km3 <- kmeans(k_data,3)
map(regions=c("Spain","Portugal","Morocco","Algeria","France","Canary Islands"),
xlim=c(-20,5),ylim=c(27,44))
map(regions=c("Australia","Portugal","Morocco","Algeria","France","Canary Islands"),
xlim=c(-20,5),ylim=c(27,44))
map(regions=c("Australia","Portugal","Morocco","Algeria","France","Canary Islands"),
xlim=c(-20,5),ylim=c(27,44))
points(longitude[km3$cluster==1],latitude[km3$cluster==1],cex=0.25,
pch=1,col="red")
points(longitude[km3$cluster==2],latitude[km3$cluster==2],cex=0.25,
pch=1,col="blue")
points(longitude[km3$cluster==3],latitude[km3$cluster==3],cex=0.25,
pch=1,col="green")
text(longitude[km3$cluster==1],latitude[km3$cluster==1]+0.20,
country[km3$cluster==1],cex=0.25,col="red")
text(longitude[km3$cluster==2],latitude[km3$cluster==2]+0.20,
country[km3$cluster==2],cex=0.25,col="blue")
text(longitude[km3$cluster==3],latitude[km3$cluster==3]+0.20,country[km3$cluster==3],cex=0.25,col="green")
map(regions=c("Australia","Portugal","Morocco","Algeria","France","Canary Islands"),
xlim=c(-200,50),ylim=c(27,44))
points(longitude[km3$cluster==1],latitude[km3$cluster==1],cex=0.25,
pch=1,col="red")
map(regions=c("Australia","Austria","Morocco","Algeria","France","Canary Islands"),
xlim=c(-200,50),ylim=c(27,44))
map(regions=c("Australia","Austria","Belgium","Canada","Chile","Canary Islands"),
xlim=c(-200,50),ylim=c(27,44))
map(regions=c("Australia","Austria","Belgium","Canada","Chile","Canary Islands"),
xlim=c(-20,5),ylim=c(27,44))
map(regions=c("Australia","Austria","Belgium","Canada","Chile","Canary Islands"),
xlim=c(-2,5),ylim=c(27,44))
map(regions=c("Australia","Austria","Belgium","Canada","Chile","Canary Islands"),
xlim=c(-5,5),ylim=c(27,44))
km3 <- kmeans(k_data,3)
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
km3$cluster
km3$ifault
km3$size
km3$centers
km3$totss
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
km3$cluster
km3$cluster==1
as.character(country)[km3$cluster==1]
c=as.character(country)[km3$cluster==1]
km3 <- kmeans(k_data,3)
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
oecd = c("Australia","Austria")
oecd = c("Australia","Austria")
summary(comparedf(c,dat2))
install.packages("arsenal")
#install.packages("arsenal")
library(arsenal)
oecd = c("Australia","Austria")
summary(comparedf(c,dat2))
oecd = c("Australia","Austria")
summary(comparedf(c,oecd))
c=as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
#install.packages("arsenal")
library(arsenal)
oecd = c("Australia","Austria")
summary(comparedf(c,oecd))
# Illustration with only two variables: hsun.annual and prec.annual
data.for.CA <- spainclimate[,c("hsun.annual","prec.annual")]
#Single linkage:
hc.single <- hclust(dist(data.for.CA),method="single")
#Complete linkage:
hc.complete <- hclust(dist(data.for.CA),method="complete")
# Centroid method:
hc.centroid=hclust(dist(data.for.CA),method="centroid")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Obtain the clusters at a certain height in the dendogram or for a given number of clusters
cutree(hc.complete,h=1000)
cutree(hc.complete,k=3)
# Illustration with only two variables: hsun.annual and prec.annual
data.for.CA <- spainclimate[,c("hsun.annual","prec.annual")]
#Single linkage:
hc.single <- hclust(dist(data.for.CA),method="single")
#Complete linkage:
hc.complete <- hclust(dist(data.for.CA),method="complete")
# Centroid method:
hc.centroid=hclust(dist(data.for.CA),method="centroid")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Illustration with only two variables: hsun.annual and prec.annual
data.for.CA <- spainclimate[,c("hsun.annual","prec.annual")]
#Single linkage:
hc.single <- hclust(dist(data.for.CA),method="single")
#Complete linkage:
hc.complete <- hclust(dist(data.for.CA),method="complete")
# Centroid method:
hc.centroid=hclust(dist(data.for.CA),method="centroid")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
# spainclimate data set
spainclimate <- read.csv("data/data-spainclimate.csv",sep=";",dec=".",header=TRUE)
attach(spainclimate)
# Illustration with only two variables: hsun.annual and prec.annual
data.for.CA <- spainclimate[,c("hsun.annual","prec.annual")]
#Single linkage:
hc.single <- hclust(dist(data.for.CA),method="single")
#Complete linkage:
hc.complete <- hclust(dist(data.for.CA),method="complete")
# Centroid method:
hc.centroid=hclust(dist(data.for.CA),method="centroid")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Obtain the clusters at a certain height in the dendogram or for a given number of clusters
cutree(hc.complete,h=1000)
cutree(hc.complete,k=3)
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Illustration with only two variables: hsun.annual and prec.annual
data.for.CA <- spainclimate[,c("hsun.annual","prec.annual")]
#Single linkage:
hc.single <- hclust(dist(data.for.CA),method="single")
#Complete linkage:
hc.complete <- hclust(dist(data.for.CA),method="complete")
# Centroid method:
hc.centroid=hclust(dist(data.for.CA),method="centroid")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=1,main="")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
# Illustration with only two variables: hsun.annual and prec.annual
data.for.CA <- spainclimate[,c("hsun.annual","prec.annual")]
#Single linkage:
hc.single <- hclust(dist(data.for.CA),method="single")
#Complete linkage:
hc.complete <- hclust(dist(data.for.CA),method="complete")
# Centroid method:
hc.centroid=hclust(dist(data.for.CA),method="centroid")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
diabetes <- read.csv("data/data-diabetes.csv",header=TRUE,sep="")
attach(diabetes)
str(diabetes)
# The package MASS is required to use the function lda()
install.packages("MASS")
# The package MASS is required to use the function lda()
# install.packages("MASS")
library(MASS)
lda.diabetes <- lda(type~glu+bp+skin+bmi)
# histograms of the scores for each group
plot(lda.diabetes)
diabetes
head(world2016)
head(world2016)
str(world2016$income.level)
str(world2016$income.level.code)
table(world2016$income.level.code)
#LIBRERIAS
library(ggplot2)
library(dplyr)
library(tibble)
library(ggrepel)
#LIBRERIAS
library(ggplot2)
library(dplyr)
library(tibble)
library(ggrepel)
View(world2016)
world2016
table(world2016$income.level.code)
mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
View(world2016)
dis_word = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
# DATA
world2016 <- read.csv("data/data-world2016.csv",header=TRUE,dec=".",sep=",")
attach(world2016)
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
'
(b) Cree una regla de discriminación para clasificar los países en los dos
grupos creados en (a) de acuerdo con las variables demográficas esperanza.vida,
tasa.fecundidad, tasa.mortalidad, crecimiento.población y población.rural.
'
dis_word = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
'
(b) Cree una regla de discriminación para clasificar los países en los dos
grupos creados en (a) de acuerdo con las variables demográficas esperanza.vida,
tasa.fecundidad, tasa.mortalidad, crecimiento.población y población.rural.
'
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
dis_data
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth,
ingreso)
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
'
(b) Cree una regla de discriminación para clasificar los países en los dos
grupos creados en (a) de acuerdo con las variables demográficas esperanza.vida,
tasa.fecundidad, tasa.mortalidad, crecimiento.población y población.rural.
'
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth,
ingreso)
world2016
attach(world2016)
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth,
ingreso)
attach(world2016)
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
'
(b) Cree una regla de discriminación para clasificar los países en los dos
grupos creados en (a) de acuerdo con las variables demográficas esperanza.vida,
tasa.fecundidad, tasa.mortalidad, crecimiento.población y población.rural.
'
attach(world2016)
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth,
ingreso)
dis_data
library(MASS)
diabetes <- read.csv("data/data-diabetes.csv",header=TRUE,sep="")
attach(diabetes)
str(diabetes)
# The package MASS is required to use the function lda()
# install.packages("MASS")
library(MASS)
lda.diabetes <- lda(type~glu+bp+skin+bmi)
lda.word <- lda(ingreso~life.expectancy+
fertility.rate+
mortality.rate+pop.growth+
pop.rural+
log.GDP.percapita+
GDP.growth
)
plot(lda.word)
View(diabetes)
predicted.class <- predict(lda.word,dis_data)$class
table(predicted.class,type)
predicted.class <- predict(lda.word,dis_data)$class
predicted.class <- predict(lda.word,dis_data)$class
table(predicted.class,ingreso)
# confusion table obtained by cross-validation (preferred)
n <- length(ingreso)
predicted.class <- factor(rep(NA,n),levels=c("high","low"))
for (i in 1:n){
lda.cv <- lda(ingreso~life.expectancy+
fertility.rate+
mortality.rate+pop.growth+
pop.rural+
log.GDP.percapita+
GDP.growth,data=dis_data[-i,])
predicted.class[i] <- predict(lda.cv,dis_data)$class
}
table(predicted.class,type)
table(predicted.class,ingreso)
View(diabetes)
n <- length(ingreso)
predicted.class <- factor(rep(NA,n),levels=c("high","low"))
for (i in 1:n){
lda.cv <- lda(ingreso~life.expectancy+
fertility.rate+
mortality.rate+pop.growth+
pop.rural+
log.GDP.percapita+
GDP.growth, data=dis_data[-i,])
predicted.class[i] <- predict(lda.cv,dis_data[i,])$class
}
table(predicted.class,ingreso)
116+33+16+35
(91+70)/(91+8+6+70)
n <- length(ingreso)
predicted.class <- factor(rep(NA,n),levels=c("high","low"))
for (i in 1:n){
lda.cv <- lda(ingreso~life.expectancy+
fertility.rate+
mortality.rate+pop.growth+
pop.rural+
log.GDP.percapita+
GDP.growth, data=dis_data[-i,])
predicted.class[i] <- predict(lda.cv,dis_data[i,])$class
}
table(predicted.class,ingreso)
()91+8+6+70
91+8+6+70
#LIBRERIAS
library(ggplot2)
library(dplyr)
library(tibble)
library(ggrepel)
library(MASS)
data.for.mahalanobis=data.frame(log.GDP.percapita,life.expectancy)
M <- colMeans(data.for.mahalanobis)
S <- cov(data.for.mahalanobis)
mahalanobis.distances.2 <- apply(data.for.mahalanobis,
1,
mahalanobis,
center=M,
cov=S)
mahalanobis.distances <- sqrt(mahalanobis.distances.2)
dist_mah = cbind.data.frame(country,mahalanobis.distances,income.level.code)
# 10 distancias más altas
dist_mah[order(-dist_mah$mahalanobis.distances),][1:10,]
# 10 distancias más bajas
dist_mah[order(dist_mah$mahalanobis.distances),][1:10,]
is_outlier <- function(x) {
return(x < quantile(x, 0.25)-1.5*IQR(x) | x>quantile(x,0.75)+1.5*IQR(x))
}
dat <- dist_mah %>% tibble::rownames_to_column(var="outlier") %>%
group_by(income.level.code) %>%
mutate(is_outlier=ifelse(is_outlier(mahalanobis.distances),
country, as.character(NA)))
ggplot(dat,
aes(y=mahalanobis.distances, x=factor(income.level.code))) +
geom_boxplot() +
geom_text_repel(aes(label=is_outlier),
na.rm=TRUE,
size = 3
) +
labs(x="Distancia de Mahalanobis", y = "Nivel de ingreso")
```{r fig.width=5, fig.height=5}
data.for.mahalanobis=data.frame(log.GDP.percapita,life.expectancy)
M <- colMeans(data.for.mahalanobis)
S <- cov(data.for.mahalanobis)
mahalanobis.distances.2 <- apply(data.for.mahalanobis,
1,
mahalanobis,
center=M,
cov=S)
mahalanobis.distances <- sqrt(mahalanobis.distances.2)
dist_mah = cbind.data.frame(country,mahalanobis.distances,income.level.code)
# 10 distancias más altas
dist_mah[order(-dist_mah$mahalanobis.distances),][1:10,]
# 10 distancias más bajas
dist_mah[order(dist_mah$mahalanobis.distances),][1:10,]
```{r width=5, height=5}
data.for.mahalanobis=data.frame(log.GDP.percapita,life.expectancy)
M <- colMeans(data.for.mahalanobis)
S <- cov(data.for.mahalanobis)
mahalanobis.distances.2 <- apply(data.for.mahalanobis,
1,
mahalanobis,
center=M,
cov=S)
mahalanobis.distances <- sqrt(mahalanobis.distances.2)
dist_mah = cbind.data.frame(country,mahalanobis.distances,income.level.code)
# 10 distancias más altas
dist_mah[order(-dist_mah$mahalanobis.distances),][1:10,]
# 10 distancias más bajas
dist_mah[order(dist_mah$mahalanobis.distances),][1:10,]
```{r width=1, height=1}
data.for.mahalanobis=data.frame(log.GDP.percapita,life.expectancy)
M <- colMeans(data.for.mahalanobis)
S <- cov(data.for.mahalanobis)
mahalanobis.distances.2 <- apply(data.for.mahalanobis,
1,
mahalanobis,
center=M,
cov=S)
dist_mah = cbind.data.frame(country,mahalanobis.distances,income.level.code)
# 10 distancias más altas
dist_mah[order(-dist_mah$mahalanobis.distances),][1:10,]
# 10 distancias más bajas
dist_mah[order(dist_mah$mahalanobis.distances),][1:10,]
