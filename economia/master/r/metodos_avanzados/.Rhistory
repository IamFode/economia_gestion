plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Illustration with only two variables: hsun.annual and prec.annual
data.for.CA <- spainclimate[,c("hsun.annual","prec.annual")]
#Single linkage:
hc.single <- hclust(dist(data.for.CA),method="single")
#Complete linkage:
hc.complete <- hclust(dist(data.for.CA),method="complete")
# Centroid method:
hc.centroid=hclust(dist(data.for.CA),method="centroid")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=1,main="")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
# Illustration with only two variables: hsun.annual and prec.annual
data.for.CA <- spainclimate[,c("hsun.annual","prec.annual")]
#Single linkage:
hc.single <- hclust(dist(data.for.CA),method="single")
#Complete linkage:
hc.complete <- hclust(dist(data.for.CA),method="complete")
# Centroid method:
hc.centroid=hclust(dist(data.for.CA),method="centroid")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.complete,labels=spainclimate$city.code,cex=0.5,main="")
plot(hc.centroid,labels=spainclimate$city.code,cex=0.5,main="")
# Dendograms:
plot(hc.single,labels=spainclimate$city.code,cex=0.5,main="")
diabetes <- read.csv("data/data-diabetes.csv",header=TRUE,sep="")
attach(diabetes)
str(diabetes)
# The package MASS is required to use the function lda()
install.packages("MASS")
# The package MASS is required to use the function lda()
# install.packages("MASS")
library(MASS)
lda.diabetes <- lda(type~glu+bp+skin+bmi)
# histograms of the scores for each group
plot(lda.diabetes)
diabetes
head(world2016)
head(world2016)
str(world2016$income.level)
str(world2016$income.level.code)
table(world2016$income.level.code)
#LIBRERIAS
library(ggplot2)
library(dplyr)
library(tibble)
library(ggrepel)
#LIBRERIAS
library(ggplot2)
library(dplyr)
library(tibble)
library(ggrepel)
View(world2016)
world2016
table(world2016$income.level.code)
mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
View(world2016)
dis_word = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
# DATA
world2016 <- read.csv("data/data-world2016.csv",header=TRUE,dec=".",sep=",")
attach(world2016)
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
'
(b) Cree una regla de discriminación para clasificar los países en los dos
grupos creados en (a) de acuerdo con las variables demográficas esperanza.vida,
tasa.fecundidad, tasa.mortalidad, crecimiento.población y población.rural.
'
dis_word = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
'
(b) Cree una regla de discriminación para clasificar los países en los dos
grupos creados en (a) de acuerdo con las variables demográficas esperanza.vida,
tasa.fecundidad, tasa.mortalidad, crecimiento.población y población.rural.
'
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
dis_data
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth,
ingreso)
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
'
(b) Cree una regla de discriminación para clasificar los países en los dos
grupos creados en (a) de acuerdo con las variables demográficas esperanza.vida,
tasa.fecundidad, tasa.mortalidad, crecimiento.población y población.rural.
'
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth,
ingreso)
world2016
attach(world2016)
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth,
ingreso)
attach(world2016)
world2016 = mutate(world2016,
ingreso = ifelse(income.level.code=="H" |
income.level.code=="UM","high","low"))
'
(b) Cree una regla de discriminación para clasificar los países en los dos
grupos creados en (a) de acuerdo con las variables demográficas esperanza.vida,
tasa.fecundidad, tasa.mortalidad, crecimiento.población y población.rural.
'
attach(world2016)
dis_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth,
ingreso)
dis_data
library(MASS)
diabetes <- read.csv("data/data-diabetes.csv",header=TRUE,sep="")
attach(diabetes)
str(diabetes)
# The package MASS is required to use the function lda()
# install.packages("MASS")
library(MASS)
lda.diabetes <- lda(type~glu+bp+skin+bmi)
lda.word <- lda(ingreso~life.expectancy+
fertility.rate+
mortality.rate+pop.growth+
pop.rural+
log.GDP.percapita+
GDP.growth
)
plot(lda.word)
View(diabetes)
predicted.class <- predict(lda.word,dis_data)$class
table(predicted.class,type)
predicted.class <- predict(lda.word,dis_data)$class
predicted.class <- predict(lda.word,dis_data)$class
table(predicted.class,ingreso)
# confusion table obtained by cross-validation (preferred)
n <- length(ingreso)
predicted.class <- factor(rep(NA,n),levels=c("high","low"))
for (i in 1:n){
lda.cv <- lda(ingreso~life.expectancy+
fertility.rate+
mortality.rate+pop.growth+
pop.rural+
log.GDP.percapita+
GDP.growth,data=dis_data[-i,])
predicted.class[i] <- predict(lda.cv,dis_data)$class
}
table(predicted.class,type)
table(predicted.class,ingreso)
View(diabetes)
n <- length(ingreso)
predicted.class <- factor(rep(NA,n),levels=c("high","low"))
for (i in 1:n){
lda.cv <- lda(ingreso~life.expectancy+
fertility.rate+
mortality.rate+pop.growth+
pop.rural+
log.GDP.percapita+
GDP.growth, data=dis_data[-i,])
predicted.class[i] <- predict(lda.cv,dis_data[i,])$class
}
table(predicted.class,ingreso)
116+33+16+35
(91+70)/(91+8+6+70)
n <- length(ingreso)
predicted.class <- factor(rep(NA,n),levels=c("high","low"))
for (i in 1:n){
lda.cv <- lda(ingreso~life.expectancy+
fertility.rate+
mortality.rate+pop.growth+
pop.rural+
log.GDP.percapita+
GDP.growth, data=dis_data[-i,])
predicted.class[i] <- predict(lda.cv,dis_data[i,])$class
}
table(predicted.class,ingreso)
()91+8+6+70
91+8+6+70
#LIBRERIAS
library(ggplot2)
library(dplyr)
library(tibble)
library(ggrepel)
library(MASS)
data.for.mahalanobis=data.frame(log.GDP.percapita,life.expectancy)
M <- colMeans(data.for.mahalanobis)
S <- cov(data.for.mahalanobis)
mahalanobis.distances.2 <- apply(data.for.mahalanobis,
1,
mahalanobis,
center=M,
cov=S)
mahalanobis.distances <- sqrt(mahalanobis.distances.2)
dist_mah = cbind.data.frame(country,mahalanobis.distances,income.level.code)
# 10 distancias más altas
dist_mah[order(-dist_mah$mahalanobis.distances),][1:10,]
# 10 distancias más bajas
dist_mah[order(dist_mah$mahalanobis.distances),][1:10,]
is_outlier <- function(x) {
return(x < quantile(x, 0.25)-1.5*IQR(x) | x>quantile(x,0.75)+1.5*IQR(x))
}
dat <- dist_mah %>% tibble::rownames_to_column(var="outlier") %>%
group_by(income.level.code) %>%
mutate(is_outlier=ifelse(is_outlier(mahalanobis.distances),
country, as.character(NA)))
ggplot(dat,
aes(y=mahalanobis.distances, x=factor(income.level.code))) +
geom_boxplot() +
geom_text_repel(aes(label=is_outlier),
na.rm=TRUE,
size = 3
) +
labs(x="Distancia de Mahalanobis", y = "Nivel de ingreso")
```{r fig.width=5, fig.height=5}
data.for.mahalanobis=data.frame(log.GDP.percapita,life.expectancy)
M <- colMeans(data.for.mahalanobis)
S <- cov(data.for.mahalanobis)
mahalanobis.distances.2 <- apply(data.for.mahalanobis,
1,
mahalanobis,
center=M,
cov=S)
mahalanobis.distances <- sqrt(mahalanobis.distances.2)
dist_mah = cbind.data.frame(country,mahalanobis.distances,income.level.code)
# 10 distancias más altas
dist_mah[order(-dist_mah$mahalanobis.distances),][1:10,]
# 10 distancias más bajas
dist_mah[order(dist_mah$mahalanobis.distances),][1:10,]
```{r width=5, height=5}
data.for.mahalanobis=data.frame(log.GDP.percapita,life.expectancy)
M <- colMeans(data.for.mahalanobis)
S <- cov(data.for.mahalanobis)
mahalanobis.distances.2 <- apply(data.for.mahalanobis,
1,
mahalanobis,
center=M,
cov=S)
mahalanobis.distances <- sqrt(mahalanobis.distances.2)
dist_mah = cbind.data.frame(country,mahalanobis.distances,income.level.code)
# 10 distancias más altas
dist_mah[order(-dist_mah$mahalanobis.distances),][1:10,]
# 10 distancias más bajas
dist_mah[order(dist_mah$mahalanobis.distances),][1:10,]
```{r width=1, height=1}
data.for.mahalanobis=data.frame(log.GDP.percapita,life.expectancy)
M <- colMeans(data.for.mahalanobis)
S <- cov(data.for.mahalanobis)
mahalanobis.distances.2 <- apply(data.for.mahalanobis,
1,
mahalanobis,
center=M,
cov=S)
dist_mah = cbind.data.frame(country,mahalanobis.distances,income.level.code)
# 10 distancias más altas
dist_mah[order(-dist_mah$mahalanobis.distances),][1:10,]
# 10 distancias más bajas
dist_mah[order(dist_mah$mahalanobis.distances),][1:10,]
c=as.character(country)[km3$cluster==1]
k_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
#LIBRERIAS
library(ggplot2)
library(dplyr)
library(tibble)
library(ggrepel)
library(MASS)
# DATA
world2016 <- read.csv("data/data-world2016.csv",header=TRUE,dec=".",sep=",")
attach(world2016)
k_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
km3 <- kmeans(k_data,3)
c=as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
k_data = data.frame(life.expectancy,
fertility.rate,
mortality.rate,
pop.growth,
pop.rural,
log.GDP.percapita,
GDP.growth)
km3 <- kmeans(k_data,3)
c=as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==1]
as.character(country)[km3$cluster==2]
as.character(country)[km3$cluster==3]
srt(km3)
srt(world2016)
world2016
world2016$OECD
as.character(country)[km3$cluster==1]
subset?
?subset
for (i in 1: length(OECD_Group)){
for (j in length(cluster1)){
if (i == j){
print(i)
}
}
}
OECD_Group = subset(country,OECD=="yes")
for (i in 1: length(OECD_Group)){
for (j in length(cluster1)){
if (i == j){
print(i)
}
}
}
cluster1 = as.character(country)[km3$cluster==1]
cluster2 = as.character(country)[km3$cluster==2]
cluster3 = 1as.character(country)[km3$cluster==3]
cluster1 = as.character(country)[km3$cluster==1]
cluster2 = as.character(country)[km3$cluster==2]
cluster3 = as.character(country)[km3$cluster==3]
OECD_Group = subset(country,OECD=="yes")
for (i in 1: length(OECD_Group)){
for (j in length(cluster1)){
if (i == j){
print(i)
}
}
}
for (i in 1: length(OECD_Group)){
print(i)
for (j in length(cluster1)){
print(j)
if (i == j){
print(i)
}
}
}
for (i in 1: length(OECD_Group)){
print(OECD_Group[i])
for (j in length(cluster1)){
print(cluster[j])
if (OEDC_group[i] == cluster[j]){
print(i)
}
}
}
for (i in 1: length(OECD_Group)){
print(OECD_Group[i])
for (j in length(cluster1)){
print(cluster1[j])
if (OEDC_group[i] == cluster[j]){
print(i)
}
}
}
for (i in 1: length(OECD_Group)){
print(OECD_Group[i])
for (j in length(cluster1)){
print(cluster1[j])
if (OEDC_group[i] == cluster[j]){
}
}
}
OECD_Group = subset(country,OECD=="yes")
for (i in 1: length(OECD_Group)){
print(OECD_Group[i])
for (j in length(cluster1)){
print(cluster1[j])
if (OEDC_group[i] == cluster[j]){
}
}
}
OECD_Group = subset(country,OECD=="yes")
for (i in 1: length(OECD_Group)){
print(OECD_Group[i])
for (j in length(cluster1)){
print(cluster1[j])
if (OECD_group[i] == cluster[j]){
}
}
}
for (i in 1: length(OECD_Group)){
print(OECD_Group[i])
for (j in length(cluster1)){
print(cluster1[j])
if (OECD_Group[i] == cluster[j]){
}
}
}
for (i in 1: length(OECD_Group)){
print(OECD_Group[i])
for (j in length(cluster1)){
print(cluster1[j])
if (OECD_Group[i] == cluster1[j]){
}
}
}
for (i in 1:length(OECD_Group)){
print(OECD_Group[i])
for (j in 1:length(cluster1)){
print(cluster1[j])
if (OECD_Group[i] == cluster1[j]){
}
}
}
for (i in 1:length(OECD_Group)){
print(OECD_Group[i])
for (j in 1:length(cluster1)){
print(cluster1[j])
if (OECD_Group[i] == cluster1[j]){
print(OECD_Group[i])
}
}
}
for (i in 1:length(OECD_Group)){
for (j in 1:length(cluster1)){
if (OECD_Group[i] == cluster1[j]){
print(OECD_Group[i])
}
}
}
OECD_Group = subset(country,OECD=="yes")
cluster = cluster1
for (i in 1:length(OECD_Group)){
for (j in 1:length(cluster)){
if (OECD_Group[i] == cluster[j]){
print(OECD_Group[i])
}
}
}
cluster = cluster2
for (i in 1:length(OECD_Group)){
for (j in 1:length(cluster)){
if (OECD_Group[i] == cluster[j]){
print(OECD_Group[i])
}
}
}
cluster = cluster3
for (i in 1:length(OECD_Group)){
for (j in 1:length(cluster)){
if (OECD_Group[i] == cluster[j]){
print(OECD_Group[i])
}
}
}
