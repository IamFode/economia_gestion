library(ks)
library(sm)
install.packages("ks")
library(ks)
install.packages("sm")
install.packages("KernSmooth")
install.packages("TDA")
load("~/git/ciencias_sociales/economia/master/r/metodos_avanzados2/stockres.rda")
#Información sobre el fichero
str(stockres)
# Se trata de un data.frame con un sola variable numérica.
# Mejor deshacemos la estructura de data.frame para obtener
# vectores numéricos (en este caso un solo vector)
s <- unlist(stockres, use.names = FALSE)
# Una función simple para crear una partición equiespaciada del rango
# de una variable X con origen en X0 y ancho de clase h
breaks <- function(x,x0,h){
b <- floor((min(x)-x0)/h) : ceiling((max(x)-x0)/h)
b <- b*h+x0
return(b)
}
# Por ejemplo:
( b <- breaks(seq(-1,1,0.1), 0.2,0.3)  )
rm(b)
# Histograma Rentabilidad Acciones
x0 <- 0         # Origen
h  <- 0.02      # Ancho de clase
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(s),col=3, lwd=2)
summary(s)
# Bondad de ajuste a una normal
library(moments)  # también en library(PerformanceAnalytics)
kurtosis(s)   # restar 3
skewness(s)
library(nortest)
lillie.test(s)
cvm.test(s)
ad.test(s)
shapiro.test(s)
str(ex0116)
# Ejemplo 2: PIB per cápita para 228 países en 2010
# Los datos son originarios de la librería Sleuth3 (fichero ex0116)
# Luego pueden cargarse como sigue:
library(Sleuth3)
install.packages("Sleuth3")
# Ejemplo 2: PIB per cápita para 228 países en 2010
# Los datos son originarios de la librería Sleuth3 (fichero ex0116)
# Luego pueden cargarse como sigue:
library(Sleuth3)
str(ex0116)
# Seleccionamos la variable de interés
GDP <- ex0116$PerCapitaGDP
# Re-escalamos respecto de la media
GDP2 <- GDP/mean(GDP)
# Boxplot:
boxplot(GDP2, col=("gold"), main="", horizontal=T, cex.lab=1.2,
xlab="PIB per cápita promedio, 2010")
# Histograma
x0 <- 1
h  <- 0.45
hist(GDP2,freq=FALSE,breaks=breaks(GDP2,x0,h),
xlab="PIB per c?pita promedio, 2010",ylab="Histograma",main="",
col = "lightblue", border = "pink", cex.lab=1.2)
# Estadísticos descriptivos
summary(GDP2)
skewness(GDP2)  # muy elevada
kurtosis(GDP2)  # más de 20 por encima del 3
# Pruebas de normalidad
cvm.test(GDP2)     # test Cramer-von Mises
lillie.test(GDP2)  # test Lilliefors
kurtosis(GDP2)  # más de 20 por encima del 3
# Pruebas de normalidad
cvm.test(GDP2)     # test Cramer-von Mises
lillie.test(GDP2)  # test Lilliefors
shapiro.test(GDP2) # test de Shapiro-Wilks
# Una línea vertical a la altura del 3er quartil (Q3)
quantile(GDP2)
# Una línea vertical a la altura del 3er quartil (Q3)
quantile(GDP2, probs = 20)
# Una línea vertical a la altura del 3er quartil (Q3)
quantile(GDP2, probs = 0.2)
# Una línea vertical a la altura del 3er quartil (Q3)
quantile(GDP2)
abline(v=quantile(GDP2)[4], col="magenta", lty=2)
lines(density(GDP2))
par(mfrow=c(2,2))
x0 <- 0
h  <- c(0.007,0.02,0.05,0.1)
for (i in 1:4)
{
hist(s,freq=FALSE,breaks=breaks(s,x0,h[i]),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2, ylim=c(0,15), xlim=c(-0.2,0.2) )
legend("topleft",legend=paste("h =",h[i]),inset=0.025,cex=1.2,bty="n")
}
#################################################
# Usando density() en stats
#################################################
ej1 <- s   # le cambio el nombre al vector con datos de acciones
dens.ej1 <- density(ej1)
plot(dens.ej1,col=3,lwd=2)
str(dens.ej1)
par(mfrow=c(1,1))
dens.ej1 <- density(ej1)
plot(dens.ej1,col=3,lwd=2)
str(dens.ej1)
# Genera una partición de 512 puntos del rango de la variable (dens.ej1$x) donde
# calcula la estimación de la densidad (dens.ej1$y)
( head ( cbind(dens.ej1$x,dens.ej1$y)  )  )
# Simultáneamente con el histograma
hist(ej1,freq=FALSE,breaks=breaks(ej1,x0=0,h=0.02),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(ej1),sd=sd(ej1)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(ej1),col=4,lwd=2)  # ajuste kernel con ventana por defecto
#################################################
# Usando sm.density() en sm
#################################################
sm.ej1 <- sm.density(ej1,eval.points=dens.ej1$x)
library(sm)
#################################################
# Usando sm.density() en sm
#################################################
sm.ej1 <- sm.density(ej1,eval.points=dens.ej1$x)
# eval.points no hace falta pero es para comparar después con dens.ej1
# por defecto hace un plot del estimador: para evitarlo: display="none"
str(sm.ej1)
