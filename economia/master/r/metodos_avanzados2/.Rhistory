library(ks)
library(sm)
install.packages("ks")
library(ks)
install.packages("sm")
install.packages("KernSmooth")
install.packages("TDA")
load("~/git/ciencias_sociales/economia/master/r/metodos_avanzados2/stockres.rda")
#Información sobre el fichero
str(stockres)
# Se trata de un data.frame con un sola variable numérica.
# Mejor deshacemos la estructura de data.frame para obtener
# vectores numéricos (en este caso un solo vector)
s <- unlist(stockres, use.names = FALSE)
# Una función simple para crear una partición equiespaciada del rango
# de una variable X con origen en X0 y ancho de clase h
breaks <- function(x,x0,h){
b <- floor((min(x)-x0)/h) : ceiling((max(x)-x0)/h)
b <- b*h+x0
return(b)
}
# Por ejemplo:
( b <- breaks(seq(-1,1,0.1), 0.2,0.3)  )
rm(b)
# Histograma Rentabilidad Acciones
x0 <- 0         # Origen
h  <- 0.02      # Ancho de clase
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(s),col=3, lwd=2)
summary(s)
# Bondad de ajuste a una normal
library(moments)  # también en library(PerformanceAnalytics)
kurtosis(s)   # restar 3
skewness(s)
library(nortest)
lillie.test(s)
cvm.test(s)
ad.test(s)
shapiro.test(s)
str(ex0116)
# Ejemplo 2: PIB per cápita para 228 países en 2010
# Los datos son originarios de la librería Sleuth3 (fichero ex0116)
# Luego pueden cargarse como sigue:
library(Sleuth3)
install.packages("Sleuth3")
# Ejemplo 2: PIB per cápita para 228 países en 2010
# Los datos son originarios de la librería Sleuth3 (fichero ex0116)
# Luego pueden cargarse como sigue:
library(Sleuth3)
str(ex0116)
# Seleccionamos la variable de interés
GDP <- ex0116$PerCapitaGDP
# Re-escalamos respecto de la media
GDP2 <- GDP/mean(GDP)
# Boxplot:
boxplot(GDP2, col=("gold"), main="", horizontal=T, cex.lab=1.2,
xlab="PIB per cápita promedio, 2010")
# Histograma
x0 <- 1
h  <- 0.45
hist(GDP2,freq=FALSE,breaks=breaks(GDP2,x0,h),
xlab="PIB per c?pita promedio, 2010",ylab="Histograma",main="",
col = "lightblue", border = "pink", cex.lab=1.2)
# Estadísticos descriptivos
summary(GDP2)
skewness(GDP2)  # muy elevada
kurtosis(GDP2)  # más de 20 por encima del 3
# Pruebas de normalidad
cvm.test(GDP2)     # test Cramer-von Mises
lillie.test(GDP2)  # test Lilliefors
kurtosis(GDP2)  # más de 20 por encima del 3
# Pruebas de normalidad
cvm.test(GDP2)     # test Cramer-von Mises
lillie.test(GDP2)  # test Lilliefors
shapiro.test(GDP2) # test de Shapiro-Wilks
# Una línea vertical a la altura del 3er quartil (Q3)
quantile(GDP2)
# Una línea vertical a la altura del 3er quartil (Q3)
quantile(GDP2, probs = 20)
# Una línea vertical a la altura del 3er quartil (Q3)
quantile(GDP2, probs = 0.2)
# Una línea vertical a la altura del 3er quartil (Q3)
quantile(GDP2)
abline(v=quantile(GDP2)[4], col="magenta", lty=2)
lines(density(GDP2))
par(mfrow=c(2,2))
x0 <- 0
h  <- c(0.007,0.02,0.05,0.1)
for (i in 1:4)
{
hist(s,freq=FALSE,breaks=breaks(s,x0,h[i]),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2, ylim=c(0,15), xlim=c(-0.2,0.2) )
legend("topleft",legend=paste("h =",h[i]),inset=0.025,cex=1.2,bty="n")
}
#################################################
# Usando density() en stats
#################################################
ej1 <- s   # le cambio el nombre al vector con datos de acciones
dens.ej1 <- density(ej1)
plot(dens.ej1,col=3,lwd=2)
str(dens.ej1)
par(mfrow=c(1,1))
dens.ej1 <- density(ej1)
plot(dens.ej1,col=3,lwd=2)
str(dens.ej1)
# Genera una partición de 512 puntos del rango de la variable (dens.ej1$x) donde
# calcula la estimación de la densidad (dens.ej1$y)
( head ( cbind(dens.ej1$x,dens.ej1$y)  )  )
# Simultáneamente con el histograma
hist(ej1,freq=FALSE,breaks=breaks(ej1,x0=0,h=0.02),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(ej1),sd=sd(ej1)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(ej1),col=4,lwd=2)  # ajuste kernel con ventana por defecto
#################################################
# Usando sm.density() en sm
#################################################
sm.ej1 <- sm.density(ej1,eval.points=dens.ej1$x)
library(sm)
#################################################
# Usando sm.density() en sm
#################################################
sm.ej1 <- sm.density(ej1,eval.points=dens.ej1$x)
# eval.points no hace falta pero es para comparar después con dens.ej1
# por defecto hace un plot del estimador: para evitarlo: display="none"
str(sm.ej1)
source("~/git/ciencias_sociales/economia/master/r/metodos_avanzados2/Script_1_Densidad.R", echo=TRUE)
install.packages('mlbench')
#install.packages('mlbench')
library(mlbench)
head(BostonHousing)
data(BostonHousing)
head(BostonHousing)
---
title: "Ejercicio 1"
output:
pdf_document: default:
css: style.css
html_notebook: default
---
---
title: "Ejercicio 1"
output:
pdf_document: default:
css: style.css
html_notebook: default
---
```{r}
#install.packages('mlbench')
library(mlbench)
#install.packages('mlbench')
library(mlbench)
#install.packages('mlbench')
library(mlbench)
# Ejercicio 1.
Considérese la base de datos Boston Housing Data con información diversa sobre la vivienda en 506 barrios del área metropolitana de Boston en 1978 y que está disponible en el archivo BostonHousing de la R-librería mlbench. Se pide:
```{r}
data(BostonHousing)
head(BostonHousing)
attach(BostonHousing)
head(BostonHousing)
hist(lstat)
hist(lstat, col=3)
hist(lstat, col=2)
hist(lstat, breaks = 2)
hist(lstat, breaks = 10)
hist(lstat, breaks = 20)
hist(lstat, breaks = 200)
hist(lstat, breaks = 100)
```{r,fig.height=3, fig.width=2}
hist(lstat, breaks = 100)
```{r,fig.height=3, fig.width=3}
hist(lstat, breaks = 100)
```{r,fig.height=5, fig.width=4}
hist(lstat, breaks = 100)
```{r,fig.height=5, fig.width=3}
1. Construir histogramas con diferentes anchos de clase para explicar la distribución de la variable lstat (porcentaje de población con estatus social en la categoría inferior). Obtener la curva del mejor ajuste normal y chequear analíticamente la normalidad de lstat.
```{r,fig.height=5, fig.width=3}
hist(lstat, breaks = 100)
```
```{r,fig.height=5, fig.width=3}
hist(lstat, breaks = 100)
hist(lstat, breaks = 100)
load("~/git/ciencias_sociales/economia/master/r/metodos_avanzados2/stockres.rda")
load("~/git/ciencias_sociales/economia/master/r/metodos_avanzados2/stockres.rda")
# Usaremos estos paquetes específicos para estimación no paramétrica
library(ks)
library(sm)
library(KernSmooth)
library(TDA)  # para kNN
# Usaremos estos paquetes específicos para estimación no paramétrica
library(ks)
library(sm)
library(KernSmooth)
library(TDA)  # para kNN
install.packages("TDA")
library(TDA)  # para kNN
# Usaremos estos paquetes específicos para estimación no paramétrica
library(ks)
library(sm)
library(KernSmooth)
library(TDA)  # para kNN
#Información sobre el fichero
str(stockres)
# Se trata de un data.frame con un sola variable numérica.
# Mejor deshacemos la estructura de data.frame para obtener
# vectores numéricos (en este caso un solo vector)
s <- unlist(stockres, use.names = FALSE)
s
# Una función simple para crear una partición equiespaciada del rango
# de una variable X con origen en X0 y ancho de clase h
breaks <- function(x,x0,h){
b <- floor((min(x)-x0)/h) : ceiling((max(x)-x0)/h)
b <- b*h+x0
return(b)
}
# Por ejemplo:
( b <- breaks(seq(-1,1,0.1), 0.2,0.3)  )
rm(b)
breaks <- function(x,x0,h){
breaks <- function(x,x0,h){
b <- floor((min(x)-x0)/h) : ceiling((max(x)-x0)/h)
b <- b*h+x0
return(b)
}
s = BostonHousing$lstat
x0 <- 0         # Origen
h  <- 0.02      # Ancho de clase
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2)
breaks <- function(x,x0,h){
b <- floor((min(x)-x0)/h) : ceiling((max(x)-x0)/h)
b <- b*h+x0
return(b)
}
x0 <- 0         # Origen
h  <- 0.02      # Ancho de clase
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2)
data(BostonHousing)
attach(BostonHousing)
s = BostonHousing$lstat
s
s
)
s
x0 <- 0         # Origen
h  <- 0.02      # Ancho de clase
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",xlab="Rentabilidad acciones",ylab="Histograma",
col = "lightblue", border = "pink",cex.lab=1.2)
b <- floor((min(x)-x0)/h) : ceiling((max(x)-x0)/h)
b <- b*h+x0
breaks <- function(x,x0,h){
b <- floor((min(x)-x0)/h) : ceiling((max(x)-x0)/h)
b <- b*h+x0
return(b)
}
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",xlab="% población con estatus social en la categoría inferior",ylab="Frecuencia",
col = "lightblue", border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
x0 <- 0         # Origen
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",
xlab="% población con estatus social en la categoría inferior",
ylab="Frecuencia",
col = "lightblue",
border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(s),col=3, lwd=2)
lines(density(s),col=3, lwd=2)
summary(s)
# functions
breaks <- function(x,x0,h){
b <- floor((min(x)-x0)/h) : ceiling((max(x)-x0)/h)
b <- b*h+x0
return(b)
}
x0 <- 0         # Origen
h  <- 0.02      # Ancho de clase
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",
xlab="% población con estatus social en la categoría inferior",
ylab="Densidad",
col = "lightblue",
border = "pink",cex.lab=1.2)
head(s)
range(s)
hist(BostonHousing$lstat)
range(s)
x0 <- 0         # Origen
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",
xlab="% población con estatus social en la categoría inferior",
ylab="Densidad",
col = "lightblue",
border = "pink",cex.lab=1.2)
lines(density(s),col=3, lwd=2)
View(BostonHousing)
max(s)-min(s)
max(s)
s = BostonHousing$lstat
s = BostonHousing$lstat
s
max(s)-min(s)
max(s)
x0 <- 0         # Origen
h  <- 0.5      # Ancho de clase
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",
xlab="% población con estatus social en la categoría inferior",
ylab="Densidad",
col = "lightblue",
border = "pink",cex.lab=1.2)
summary(s)
x0 <- 0         # Origen
h  <- 1      # Ancho de clase
histo = function(s,x0,h,xlab){
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main=xlab,
xlab=,
ylab="Densidad",
col = "lightblue",
border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(s),col=3, lwd=2)
summary(s)
}
histo(0,1,"% población con estatus social en la categoría inferior")
histo = function(s,x0,h,xlab){
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",
xlab=xlab,
ylab="Densidad",
col = "lightblue",
border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(s),col=3, lwd=2)
summary(s)
}
histo(0,1,"% población con estatus social en la categoría inferior")
histo(0,1,% población con estatus social en la categoría inferior)
histo = function(s,x0,h){
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",
xlab="",
ylab="Densidad",
col = "lightblue",
border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(s),col=3, lwd=2)
summary(s)
}
histo(0,1,% población con estatus social en la categoría inferior)
histo = function(s,x0,h){
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",
xlab="",
ylab="Densidad",
col = "lightblue",
border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(s),col=3, lwd=2)
summary(s)
}
histo(0,1)
histo(s,0,1)
histo = function(s,x0,h){
hist(s,freq=FALSE,breaks=breaks(s,x0,h),
main="",
xlab="",
ylab="Densidad",
col = "lightblue",
border = "pink",cex.lab=1.2)
curve(dnorm(x,mean=mean(s),sd=sd(s)), col="magenta", add=TRUE, lty=1, lwd=2)
lines(density(s),col=3, lwd=2)
summary(s)
}
histo(s,0,1)
histo(s,0,0.5)
library(moments)  # también en library(PerformanceAnalytics)
lillie.test(s)
library(nortest)
lillie.test(s)
